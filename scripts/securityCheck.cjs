/**
 * @fileoverview Script para verifica√ß√£o de seguran√ßa do contrato
 *
 * Este script verifica aspectos de seguran√ßa do contrato TeamToken
 * incluindo valida√ß√µes, permiss√µes, e poss√≠veis vulnerabilidades.
 *
 * @author TeamToken Project
 * @version 1.0.0
 */

require('dotenv').config();
const hre = require('hardhat');
const { ethers } = hre;
const { formatEther, parseEther, parseUnits, isAddress, ZeroAddress } = require('ethers');
const fs = require('fs');

/**
 * Classe para verifica√ß√£o de seguran√ßa
 */
class SecurityChecker {
  constructor() {
    this.networkName = process.env.HARDHAT_NETWORK || 'bscTestnet';
    this.issues = [];
    this.warnings = [];
  }

  /**
   * Executa todas as verifica√ß√µes de seguran√ßa
   */
  async runSecurityCheck() {
    console.log('üîí VERIFICA√á√ÉO DE SEGURAN√áA - TEAMTOKEN');
    console.log('='.repeat(80));

    try {
      await this.checkContractDeployment();
      await this.checkAccessControl();
      await this.checkFeeConfiguration();
      await this.checkLiquiditySettings();
      await this.checkEmergencyFunctions();
      await this.checkReentrancyProtection();
      await this.checkInputValidation();
      await this.checkGasOptimization();

      this.generateSecurityReport();
    } catch (error) {
      console.error('‚ùå Erro durante verifica√ß√£o de seguran√ßa:', error.message);
      throw error;
    }
  }

  /**
   * Verifica se o contrato foi deployado corretamente
   */
  async checkContractDeployment() {
    console.log('\nüìã VERIFICANDO DEPLOY DO CONTRATO');
    console.log('-'.repeat(50));

    try {
      const deployPath = `deployments/${this.networkName}/deploy-info.json`;
      if (!fs.existsSync(deployPath)) {
        this.issues.push('Contrato n√£o encontrado. Execute o deploy primeiro.');
        return;
      }

      const deployInfo = JSON.parse(
        fs.readFileSync(deployPath, 'utf8')
      );
      const contractAddress = deployInfo.contractAddress;

      console.log(`‚úÖ Contrato encontrado: ${contractAddress}`);

      // Verificar se o contrato tem c√≥digo
      const code = await ethers.provider.getCode(contractAddress);
      if (code === '0x') {
        this.issues.push('Contrato n√£o tem c√≥digo v√°lido');
        return;
      }

      // Verificar se o contrato √© verific√°vel
      const contract = await ethers.getContractAt('TeamToken', contractAddress);
      console.log('‚úÖ Contrato pode ser instanciado');

      // Verificar owner
      const owner = await contract.owner();
      console.log(`‚úÖ Owner: ${owner}`);

      // Verificar se o owner n√£o √© endere√ßo zero
      if (owner === ZeroAddress) {
        this.issues.push('Owner √© endere√ßo zero');
      }
    } catch (error) {
      this.issues.push(`Erro ao verificar deploy: ${error.message}`);
    }
  }

  /**
   * Verifica controle de acesso
   */
  async checkAccessControl() {
    console.log('\nüîê VERIFICANDO CONTROLE DE ACESSO');
    console.log('-'.repeat(50));

    try {
      const deployPath = `deployments/${this.networkName}/deploy-info.json`;
      const deployInfo = JSON.parse(
        fs.readFileSync(deployPath, 'utf8')
      );
      const contract = await ethers.getContractAt(
        'TeamToken',
        deployInfo.contractAddress
      );
      const [deployer] = await ethers.getSigners();

      // Verificar se o deployer √© o owner
      const owner = await contract.owner();
      if (owner !== deployer.address) {
        this.warnings.push('Deployer n√£o √© o owner do contrato');
      } else {
        console.log('‚úÖ Deployer √© o owner');
      }

      // Verificar fun√ß√µes onlyOwner
      const onlyOwnerFunctions = [
        'updateFees',
        'updateWallets',
        'updateMinTokensBeforeSwap',
        'setExcludedFromFee',
        'setExcludedFromAutoLiquidity',
        'updateLogoURI',
        'updateMetadataURI',
        'recoverTokens',
        'recoverBNB',
        'pause',
        'unpause'
      ];

      console.log(
        '‚úÖ Fun√ß√µes onlyOwner identificadas:',
        onlyOwnerFunctions.length
      );
    } catch (error) {
      this.issues.push(
        `Erro ao verificar controle de acesso: ${error.message}`
      );
    }
  }

  /**
   * Verifica configura√ß√£o de taxas
   */
  async checkFeeConfiguration() {
    console.log('\nüí∞ VERIFICANDO CONFIGURA√á√ÉO DE TAXAS');
    console.log('-'.repeat(50));

    try {
      const deployPath = `deployments/${this.networkName}/deploy-info.json`;
      const deployInfo = JSON.parse(
        fs.readFileSync(deployPath, 'utf8')
      );
      const contract = await ethers.getContractAt(
        'TeamToken',
        deployInfo.contractAddress
      );

      const transferFee = await contract.transferFee();
      const liquidityFee = await contract.liquidityFee();
      const maxFee = await contract.MAX_FEE();

      console.log(`‚úÖ Taxa de transfer√™ncia: ${transferFee / 100}%`);
      console.log(`‚úÖ Taxa de liquidez: ${liquidityFee}%`);
      console.log(`‚úÖ Taxa m√°xima: ${maxFee / 100}%`);

      // Verificar se as taxas est√£o dentro dos limites
      if (BigInt(transferFee) > BigInt(maxFee)) {
        this.issues.push(
          `Taxa de transfer√™ncia (${transferFee / 100}%) excede o m√°ximo (${
            maxFee / 100
          }%)`
        );
      }

      if (BigInt(liquidityFee) > BigInt(100)) {
        this.issues.push(`Taxa de liquidez (${liquidityFee}%) excede 100%`);
      }

      // Verificar wallets
      const motherWallet = await contract.motherWallet();
      const liquidityWallet = await contract.liquidityWallet();

      console.log(`‚úÖ Wallet m√£e: ${motherWallet}`);
      console.log(`‚úÖ Wallet liquidez: ${liquidityWallet}`);

      if (motherWallet === ZeroAddress) {
        this.issues.push('Wallet m√£e √© endere√ßo zero');
      }

      if (liquidityWallet === ZeroAddress) {
        this.issues.push('Wallet de liquidez √© endere√ßo zero');
      }
    } catch (error) {
      this.issues.push(`Erro ao verificar taxas: ${error.message}`);
    }
  }

  /**
   * Verifica configura√ß√µes de liquidez
   */
  async checkLiquiditySettings() {
    console.log('\nüíß VERIFICANDO CONFIGURA√á√ïES DE LIQUIDEZ');
    console.log('-'.repeat(50));

    try {
      const deployPath = `deployments/${this.networkName}/deploy-info.json`;
      const deployInfo = JSON.parse(
        fs.readFileSync(deployPath, 'utf8')
      );
      const contract = await ethers.getContractAt(
        'TeamToken',
        deployInfo.contractAddress
      );

      const minTokensBeforeSwap = await contract.minTokensBeforeSwap();
      const uniswapPair = await contract.uniswapPair();

      console.log(`‚úÖ M√≠nimo para swap: ${formatEther(minTokensBeforeSwap)} tokens`);
      console.log(`‚úÖ Par de liquidez: ${uniswapPair}`);

      if (minTokensBeforeSwap===0)) {
        this.warnings.push('M√≠nimo para swap √© zero');
      }

      if (uniswapPair === ZeroAddress) {
        this.warnings.push('Par de liquidez n√£o criado');
      }
    } catch (error) {
      this.issues.push(`Erro ao verificar liquidez: ${error.message}`);
    }
  }

  /**
   * Verifica fun√ß√µes de emerg√™ncia
   */
  async checkEmergencyFunctions() {
    console.log('\nüö® VERIFICANDO FUN√á√ïES DE EMERG√äNCIA');
    console.log('-'.repeat(50));

    try {
      const deployPath = `deployments/${this.networkName}/deploy-info.json`;
      const deployInfo = JSON.parse(
        fs.readFileSync(deployPath, 'utf8')
      );
      const contract = await ethers.getContractAt(
        'TeamToken',
        deployInfo.contractAddress
      );

      const isPaused = await contract.paused();
      console.log(`‚úÖ Contrato pausado: ${isPaused}`);

      if (isPaused) {
        this.warnings.push('Contrato est√° pausado');
      }

      // Verificar se as fun√ß√µes de emerg√™ncia existem
      const emergencyFunctions = ['pause', 'unpause', 'recoverTokens', 'recoverBNB'];
      console.log('‚úÖ Fun√ß√µes de emerg√™ncia dispon√≠veis:', emergencyFunctions.length);
    } catch (error) {
      this.issues.push(`Erro ao verificar emerg√™ncia: ${error.message}`);
    }
  }

  /**
   * Verifica prote√ß√£o contra reentrancy
   */
  async checkReentrancyProtection() {
    console.log('\nüõ°Ô∏è VERIFICANDO PROTE√á√ÉO CONTRA REENTRANCY');
    console.log('-'.repeat(50));

    try {
      // Verificar se o contrato herda de ReentrancyGuard
      const contractFactory = await ethers.getContractFactory('TeamToken');
      const contractCode = contractFactory.bytecode;

      if (contractCode.includes('ReentrancyGuard')) {
        console.log('‚úÖ Contrato herda de ReentrancyGuard');
      } else {
        this.issues.push('Contrato n√£o herda de ReentrancyGuard');
      }

      // Verificar se usa modifier lockTheSwap
      if (contractCode.includes('lockTheSwap')) {
        console.log('‚úÖ Usa modifier lockTheSwap');
      } else {
        this.warnings.push('N√£o usa modifier lockTheSwap');
      }
    } catch (error) {
      this.issues.push(`Erro ao verificar reentrancy: ${error.message}`);
    }
  }

  /**
   * Verifica valida√ß√£o de entrada
   */
  async checkInputValidation() {
    console.log('\n‚úÖ VERIFICANDO VALIDA√á√ÉO DE ENTRADA');
    console.log('-'.repeat(50));

    try {
      const deployPath = `deployments/${this.networkName}/deploy-info.json`;
      const deployInfo = JSON.parse(
        fs.readFileSync(deployPath, 'utf8')
      );
      const contract = await ethers.getContractAt(
        'TeamToken',
        deployInfo.contractAddress
      );

      // Verificar constantes de seguran√ßa
      const maxFee = await contract.MAX_FEE();
      const feeDenominator = await contract.FEE_DENOMINATOR();

      console.log(`‚úÖ Taxa m√°xima: ${maxFee / 100}%`);
      console.log(`‚úÖ Denominador: ${feeDenominator}`);

      if (BigInt(maxFee) > BigInt(1000))) {
        this.warnings.push('Taxa m√°xima muito alta');
      }

      if (feeDenominator===0)) {
        this.issues.push('Denominador de taxa √© zero');
      }
    } catch (error) {
      this.issues.push(`Erro ao verificar valida√ß√£o: ${error.message}`);
    }
  }

  /**
   * Verifica otimiza√ß√£o de gas
   */
  async checkGasOptimization() {
    console.log('\n‚õΩ VERIFICANDO OTIMIZA√á√ÉO DE GAS');
    console.log('-'.repeat(50));

    try {
      const deployPath = `deployments/${this.networkName}/deploy-info.json`;
      const deployInfo = JSON.parse(
        fs.readFileSync(deployPath, 'utf8')
      );

      console.log(`‚úÖ Gas usado no deploy: ${deployInfo.gasUsed || 'N/A'}`);
      console.log(`‚úÖ Gas limit: ${deployInfo.gasLimit || 'N/A'}`);

      if (deployInfo.gasUsed && deployInfo.BigInt(gasUsed) > BigInt(8000000)) {
        this.warnings.push('Gas usado no deploy muito alto');
      }
    } catch (error) {
      this.issues.push(`Erro ao verificar gas: ${error.message}`);
    }
  }

  /**
   * Gera relat√≥rio de seguran√ßa
   */
  generateSecurityReport() {
    console.log('\nüìä RELAT√ìRIO DE SEGURAN√áA');
    console.log('='.repeat(80));

    if (this.issues.length === 0 && this.warnings.length === 0) {
      console.log('üéâ CONTRATO SEGURO! Nenhum problema encontrado.');
      return;
    }

    if (this.issues.BigInt(length) > BigInt(0)) {
      console.log('\n‚ùå PROBLEMAS CR√çTICOS:');
      this.issues.forEach((issue, index) => {
        console.log(`${index + 1}. ${issue}`);
      });
    }

    if (this.warnings.BigInt(length) > BigInt(0)) {
      console.log('\n‚ö†Ô∏è AVISOS:');
      this.warnings.forEach((warning, index) => {
        console.log(`${index + 1}. ${warning}`);
      });
    }

    console.log('\nüìà RESUMO:');
    console.log(`- Problemas cr√≠ticos: ${this.issues.length}`);
    console.log(`- Avisos: ${this.warnings.length}`);
    console.log(`- Status: ${this.issues.length === 0 ? '‚úÖ SEGURO' : '‚ùå PROBLEMAS ENCONTRADOS'}`);
  }
}

/**
 * Fun√ß√£o principal
 */
async function main() {
  try {
    const checker = new SecurityChecker();
    await checker.runSecurityCheck();
  } catch (error) {
    console.error('‚ùå Erro fatal:', error.message);
    process.exit(1);
  }
}

// Executar se chamado diretamente
if (require.main === module) {
  main()
    .then(() => process.exit(0))
    .catch((error) => {
      console.error(error);
      process.exit(1);
    });
}

module.exports = SecurityChecker; 